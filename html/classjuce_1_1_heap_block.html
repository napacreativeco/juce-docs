<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: juce::HeapBlock&lt; ElementType, throwOnFailure &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>juce</b></li><li class="navelem"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classjuce_1_1_heap_block-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">juce::HeapBlock&lt; ElementType, throwOnFailure &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="juce___heap_block_8h_source.html">juce_HeapBlock.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3560f5f62ca9d48ac182c501b2957ea3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a3560f5f62ca9d48ac182c501b2957ea3">Type</a> = ElementType</td></tr>
<tr class="separator:a3560f5f62ca9d48ac182c501b2957ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc43d1f0b74a6a3dd8d0929c6bb590e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#adc43d1f0b74a6a3dd8d0929c6bb590e9">HeapBlock</a> ()=default</td></tr>
<tr class="separator:adc43d1f0b74a6a3dd8d0929c6bb590e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af3e7460475f1f6ffbb02a31bfd7a5"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , std::enable_if_t&lt; std::is_convertible_v&lt; SizeType, int &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a17af3e7460475f1f6ffbb02a31bfd7a5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a17af3e7460475f1f6ffbb02a31bfd7a5">HeapBlock</a> (SizeType numElements)</td></tr>
<tr class="separator:a17af3e7460475f1f6ffbb02a31bfd7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bc396b050198d66b5c09f8802a4db9"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , std::enable_if_t&lt; std::is_convertible_v&lt; SizeType, int &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae6bc396b050198d66b5c09f8802a4db9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#ae6bc396b050198d66b5c09f8802a4db9">HeapBlock</a> (SizeType numElements, bool initialiseToZero)</td></tr>
<tr class="separator:ae6bc396b050198d66b5c09f8802a4db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fa32ace7e6ddea90750e71ff4a3a1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a10fa32ace7e6ddea90750e71ff4a3a1b">~HeapBlock</a> ()</td></tr>
<tr class="separator:a10fa32ace7e6ddea90750e71ff4a3a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa96cc97532993e50716d40720569d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#aafa96cc97532993e50716d40720569d3">HeapBlock</a> (<a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:aafa96cc97532993e50716d40720569d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c988f1b57284bb4589a7abc1e7d300b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a2c988f1b57284bb4589a7abc1e7d300b">operator=</a> (<a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a2c988f1b57284bb4589a7abc1e7d300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2652c7aab9a9dbe4a7924aa88680df8d"><td class="memTemplParams" colspan="2">template&lt;class OtherElementType , bool otherThrowOnFailure, typename  = AllowConversion&lt;OtherElementType&gt;&gt; </td></tr>
<tr class="memitem:a2652c7aab9a9dbe4a7924aa88680df8d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a2652c7aab9a9dbe4a7924aa88680df8d">HeapBlock</a> (<a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; OtherElementType, otherThrowOnFailure &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a2652c7aab9a9dbe4a7924aa88680df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bbcb81fbcff1db2ab9365f22f25b52"><td class="memTemplParams" colspan="2">template&lt;class OtherElementType , bool otherThrowOnFailure, typename  = AllowConversion&lt;OtherElementType&gt;&gt; </td></tr>
<tr class="memitem:ad7bbcb81fbcff1db2ab9365f22f25b52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#ad7bbcb81fbcff1db2ab9365f22f25b52">operator=</a> (<a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; OtherElementType, otherThrowOnFailure &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="separator:ad7bbcb81fbcff1db2ab9365f22f25b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fc6b8dfe5e1e6737200c8de6343e40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a84fc6b8dfe5e1e6737200c8de6343e40">operator ElementType *</a> () const noexcept</td></tr>
<tr class="separator:a84fc6b8dfe5e1e6737200c8de6343e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac017d86f89dadec3f511971a3e3cbe46"><td class="memItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#ac017d86f89dadec3f511971a3e3cbe46">get</a> () const noexcept</td></tr>
<tr class="separator:ac017d86f89dadec3f511971a3e3cbe46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9c0594d3f6d8be0cbf1670e9f5248d"><td class="memItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#acb9c0594d3f6d8be0cbf1670e9f5248d">getData</a> () const noexcept</td></tr>
<tr class="separator:acb9c0594d3f6d8be0cbf1670e9f5248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7320cd1077e72b1c91e38617687090"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a3a7320cd1077e72b1c91e38617687090">operator void *</a> () const noexcept</td></tr>
<tr class="separator:a3a7320cd1077e72b1c91e38617687090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed0ef379ce0cb47abe9007ed55ec7f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a5ed0ef379ce0cb47abe9007ed55ec7f8">operator const void *</a> () const noexcept</td></tr>
<tr class="separator:a5ed0ef379ce0cb47abe9007ed55ec7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ed7b034bd971612be1ba174ab9caa4"><td class="memItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#af9ed7b034bd971612be1ba174ab9caa4">operator-&gt;</a> () const noexcept</td></tr>
<tr class="separator:af9ed7b034bd971612be1ba174ab9caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba845b2dd3e84c2eeed3d61cad7241e"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:adba845b2dd3e84c2eeed3d61cad7241e"><td class="memTemplItemLeft" align="right" valign="top">ElementType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#adba845b2dd3e84c2eeed3d61cad7241e">operator[]</a> (IndexType index) const noexcept</td></tr>
<tr class="separator:adba845b2dd3e84c2eeed3d61cad7241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffaa36b28f8a7a64bcd980980bd6c60"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a6ffaa36b28f8a7a64bcd980980bd6c60"><td class="memTemplItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a6ffaa36b28f8a7a64bcd980980bd6c60">operator+</a> (IndexType index) const noexcept</td></tr>
<tr class="separator:a6ffaa36b28f8a7a64bcd980980bd6c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef42df8e69f0805ccbb5d44f1df32a21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#aef42df8e69f0805ccbb5d44f1df32a21">operator==</a> (const ElementType *otherPointer) const noexcept</td></tr>
<tr class="separator:aef42df8e69f0805ccbb5d44f1df32a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5ae273ec381cf3a70c2c8907360a57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a4b5ae273ec381cf3a70c2c8907360a57">operator!=</a> (const ElementType *otherPointer) const noexcept</td></tr>
<tr class="separator:a4b5ae273ec381cf3a70c2c8907360a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e477b206e0333ab3f05728e1b939990"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:a7e477b206e0333ab3f05728e1b939990"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a7e477b206e0333ab3f05728e1b939990">malloc</a> (SizeType newNumElements, size_t elementSize=sizeof(ElementType))</td></tr>
<tr class="separator:a7e477b206e0333ab3f05728e1b939990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9433ed4bf66f63f7c679dea07a2919"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:afa9433ed4bf66f63f7c679dea07a2919"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#afa9433ed4bf66f63f7c679dea07a2919">calloc</a> (SizeType newNumElements, const size_t elementSize=sizeof(ElementType))</td></tr>
<tr class="separator:afa9433ed4bf66f63f7c679dea07a2919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf31950fc090b3b97d9e23539f89caca"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:adf31950fc090b3b97d9e23539f89caca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#adf31950fc090b3b97d9e23539f89caca">allocate</a> (SizeType newNumElements, bool initialiseToZero)</td></tr>
<tr class="separator:adf31950fc090b3b97d9e23539f89caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d26dfb08dc6f0e63a5e2fb2545b3f"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:aef5d26dfb08dc6f0e63a5e2fb2545b3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#aef5d26dfb08dc6f0e63a5e2fb2545b3f">realloc</a> (SizeType newNumElements, size_t elementSize=sizeof(ElementType))</td></tr>
<tr class="separator:aef5d26dfb08dc6f0e63a5e2fb2545b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34dfdaf6aa53bfd4a951f2977849b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free</a> () noexcept</td></tr>
<tr class="separator:af34dfdaf6aa53bfd4a951f2977849b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4553291a09020d9b9f710d3db159a3d0"><td class="memTemplParams" colspan="2">template&lt;bool otherBlockThrows&gt; </td></tr>
<tr class="memitem:a4553291a09020d9b9f710d3db159a3d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a4553291a09020d9b9f710d3db159a3d0">swapWith</a> (<a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; ElementType, otherBlockThrows &gt; &amp;other) noexcept</td></tr>
<tr class="separator:a4553291a09020d9b9f710d3db159a3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443478c6c85b1c70c2139804165f75f8"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:a443478c6c85b1c70c2139804165f75f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classjuce_1_1_heap_block.html#a443478c6c85b1c70c2139804165f75f8">clear</a> (SizeType numElements) noexcept</td></tr>
<tr class="separator:a443478c6c85b1c70c2139804165f75f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ElementType, bool throwOnFailure = false&gt;<br />
class juce::HeapBlock&lt; ElementType, throwOnFailure &gt;</div><p>Very simple container class to hold a pointer to some data on the heap.</p>
<p>When you need to allocate some heap storage for something, always try to use this class instead of allocating the memory directly using malloc/free.</p>
<p>A <a class="el" href="classjuce_1_1_heap_block.html">HeapBlock&lt;char&gt;</a> object can be treated in pretty much exactly the same way as an char*, but as long as you allocate it on the stack or as a class member, it's almost impossible for it to leak memory.</p>
<p>It also makes your code much more concise and readable than doing the same thing using direct allocations,</p>
<p>E.g. instead of this: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>* temp = (<span class="keywordtype">int</span>*) malloc (1024 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line">memcpy (temp, xyz, 1024 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line"><a class="code hl_function" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free</a> (temp);</div>
<div class="line">temp = (<span class="keywordtype">int</span>*) calloc (2048 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line">temp[0] = 1234;</div>
<div class="line">memcpy (foobar, temp, 2048 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line"><a class="code hl_function" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free</a> (temp);</div>
<div class="ttc" id="aclassjuce_1_1_heap_block_html_af34dfdaf6aa53bfd4a951f2977849b77"><div class="ttname"><a href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">juce::HeapBlock::free</a></div><div class="ttdeci">void free() noexcept</div><div class="ttdef"><b>Definition:</b> juce_HeapBlock.h:300</div></div>
</div><!-- fragment --><p>..you could just write this: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classjuce_1_1_heap_block.html">HeapBlock&lt;int&gt;</a> temp (1024);</div>
<div class="line">memcpy (temp, xyz, 1024 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line">temp.calloc (2048);</div>
<div class="line">temp[0] = 1234;</div>
<div class="line">memcpy (foobar, temp, 2048 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="ttc" id="aclassjuce_1_1_heap_block_html"><div class="ttname"><a href="classjuce_1_1_heap_block.html">juce::HeapBlock</a></div><div class="ttdef"><b>Definition:</b> juce_HeapBlock.h:87</div></div>
</div><!-- fragment --><p>The class is extremely lightweight, containing only a pointer to the data, and exposes malloc/realloc/calloc/free methods that do the same jobs as their less object-oriented counterparts. Despite adding safety, you probably won't sacrifice any performance by using this in place of normal pointers.</p>
<p>The throwOnFailure template parameter can be set to true if you'd like the class to throw a std::bad_alloc exception when an allocation fails. If this is false, then a failed allocation will just leave the heapblock with a null pointer (assuming that the system's malloc() function doesn't throw).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjuce_1_1_array.html">Array</a>, <a class="el" href="classjuce_1_1_owned_array.html">OwnedArray</a>, <a class="el" href="classjuce_1_1_memory_block.html">MemoryBlock</a></dd></dl>
<p>@tags{Core} </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3560f5f62ca9d48ac182c501b2957ea3" name="a3560f5f62ca9d48ac182c501b2957ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3560f5f62ca9d48ac182c501b2957ea3">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::Type =  ElementType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This typedef can be used to get the type of the heapblock's elements. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc43d1f0b74a6a3dd8d0929c6bb590e9" name="adc43d1f0b74a6a3dd8d0929c6bb590e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc43d1f0b74a6a3dd8d0929c6bb590e9">&#9670;&#160;</a></span>HeapBlock() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::HeapBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> which is initially just a null pointer.</p>
<p>After creation, you can resize the array using the malloc(), calloc(), or <a class="el" href="classjuce_1_1_heap_block.html#aef5d26dfb08dc6f0e63a5e2fb2545b3f">realloc()</a> methods. </p>

</div>
</div>
<a id="a17af3e7460475f1f6ffbb02a31bfd7a5" name="a17af3e7460475f1f6ffbb02a31bfd7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17af3e7460475f1f6ffbb02a31bfd7a5">&#9670;&#160;</a></span>HeapBlock() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType , std::enable_if_t&lt; std::is_convertible_v&lt; SizeType, int &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::HeapBlock </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> containing a number of elements.</p>
<p>The contents of the block are undefined, as it will have been created by a malloc call.</p>
<p>If you want an array of zero values, you can use the calloc() method or the other constructor that takes an InitialisationState parameter. </p>

</div>
</div>
<a id="ae6bc396b050198d66b5c09f8802a4db9" name="ae6bc396b050198d66b5c09f8802a4db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bc396b050198d66b5c09f8802a4db9">&#9670;&#160;</a></span>HeapBlock() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType , std::enable_if_t&lt; std::is_convertible_v&lt; SizeType, int &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::HeapBlock </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialiseToZero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> containing a number of elements.</p>
<p>The initialiseToZero parameter determines whether the new memory should be cleared, or left uninitialised. </p>

</div>
</div>
<a id="a10fa32ace7e6ddea90750e71ff4a3a1b" name="a10fa32ace7e6ddea90750e71ff4a3a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fa32ace7e6ddea90750e71ff4a3a1b">&#9670;&#160;</a></span>~HeapBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::~<a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. This will free the data, if any has been allocated. </p>

</div>
</div>
<a id="aafa96cc97532993e50716d40720569d3" name="aafa96cc97532993e50716d40720569d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa96cc97532993e50716d40720569d3">&#9670;&#160;</a></span>HeapBlock() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::HeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; ElementType, throwOnFailure &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor </p>

</div>
</div>
<a id="a2652c7aab9a9dbe4a7924aa88680df8d" name="a2652c7aab9a9dbe4a7924aa88680df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2652c7aab9a9dbe4a7924aa88680df8d">&#9670;&#160;</a></span>HeapBlock() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;class OtherElementType , bool otherThrowOnFailure, typename  = AllowConversion&lt;OtherElementType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::HeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; OtherElementType, otherThrowOnFailure &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converting move constructor. Only enabled if this is a HeapBlock&lt;Base*&gt; and the other object is a HeapBlock&lt;Derived*&gt;, where std::is_base_of_v&lt;Base, Derived&gt; == true. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf31950fc090b3b97d9e23539f89caca" name="adf31950fc090b3b97d9e23539f89caca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf31950fc090b3b97d9e23539f89caca">&#9670;&#160;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialiseToZero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a specified amount of memory and optionally clears it. This does the same job as either malloc() or calloc(), depending on the initialiseToZero parameter. </p>

</div>
</div>
<a id="afa9433ed4bf66f63f7c679dea07a2919" name="afa9433ed4bf66f63f7c679dea07a2919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9433ed4bf66f63f7c679dea07a2919">&#9670;&#160;</a></span>calloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::calloc </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>sizeof&#160;(ElementType)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a specified amount of memory and clears it. This does the same job as the malloc() method, but clears the memory that it allocates. </p>

</div>
</div>
<a id="a443478c6c85b1c70c2139804165f75f8" name="a443478c6c85b1c70c2139804165f75f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443478c6c85b1c70c2139804165f75f8">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This fills the block with zeros, up to the number of elements specified. Since the block has no way of knowing its own size, you must make sure that the number of elements you specify doesn't exceed the allocated size. </p>

</div>
</div>
<a id="af34dfdaf6aa53bfd4a951f2977849b77" name="af34dfdaf6aa53bfd4a951f2977849b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34dfdaf6aa53bfd4a951f2977849b77">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees any currently-allocated data. This will free the data and reset this object to be a null pointer. </p>

</div>
</div>
<a id="ac017d86f89dadec3f511971a3e3cbe46" name="ac017d86f89dadec3f511971a3e3cbe46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac017d86f89dadec3f511971a3e3cbe46">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType * <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a raw pointer to the allocated data. This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free()</a> method. </p>

</div>
</div>
<a id="acb9c0594d3f6d8be0cbf1670e9f5248d" name="acb9c0594d3f6d8be0cbf1670e9f5248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9c0594d3f6d8be0cbf1670e9f5248d">&#9670;&#160;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType * <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a raw pointer to the allocated data. This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free()</a> method. </p>

</div>
</div>
<a id="a7e477b206e0333ab3f05728e1b939990" name="a7e477b206e0333ab3f05728e1b939990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e477b206e0333ab3f05728e1b939990">&#9670;&#160;</a></span>malloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::malloc </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>sizeof&#160;(ElementType)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a specified amount of memory.</p>
<p>This uses the normal malloc to allocate an amount of memory for this object. Any previously allocated memory will be freed by this method.</p>
<p>The number of bytes allocated will be (newNumElements * elementSize). Normally you wouldn't need to specify the second parameter, but it can be handy if you need to allocate a size in bytes rather than in terms of the number of elements.</p>
<p>The data that is allocated will be freed when this object is deleted, or when you call <a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free()</a> or any of the allocation methods. </p>

</div>
</div>
<a id="a5ed0ef379ce0cb47abe9007ed55ec7f8" name="a5ed0ef379ce0cb47abe9007ed55ec7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed0ef379ce0cb47abe9007ed55ec7f8">&#9670;&#160;</a></span>operator const void *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a void pointer to the allocated data. This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free()</a> method. </p>

</div>
</div>
<a id="a84fc6b8dfe5e1e6737200c8de6343e40" name="a84fc6b8dfe5e1e6737200c8de6343e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fc6b8dfe5e1e6737200c8de6343e40">&#9670;&#160;</a></span>operator ElementType *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator ElementType * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a raw pointer to the allocated data. This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free()</a> method. </p>

</div>
</div>
<a id="a3a7320cd1077e72b1c91e38617687090" name="a3a7320cd1077e72b1c91e38617687090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7320cd1077e72b1c91e38617687090">&#9670;&#160;</a></span>operator void *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a void pointer to the allocated data. This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="classjuce_1_1_heap_block.html#af34dfdaf6aa53bfd4a951f2977849b77">free()</a> method. </p>

</div>
</div>
<a id="a4b5ae273ec381cf3a70c2c8907360a57" name="a4b5ae273ec381cf3a70c2c8907360a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5ae273ec381cf3a70c2c8907360a57">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>otherPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares the pointer with another pointer. This can be handy for checking whether this is a null pointer. </p>

</div>
</div>
<a id="a6ffaa36b28f8a7a64bcd980980bd6c60" name="a6ffaa36b28f8a7a64bcd980980bd6c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffaa36b28f8a7a64bcd980980bd6c60">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType * <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to a data element at an offset from the start of the array. This is the same as doing pointer arithmetic on the raw pointer itself. </p>

</div>
</div>
<a id="af9ed7b034bd971612be1ba174ab9caa4" name="af9ed7b034bd971612be1ba174ab9caa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ed7b034bd971612be1ba174ab9caa4">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType * <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lets you use indirect calls to the first element in the array. Obviously this will cause problems if the array hasn't been initialised, because it'll be referencing a null pointer. </p>

</div>
</div>
<a id="a2c988f1b57284bb4589a7abc1e7d300b" name="a2c988f1b57284bb4589a7abc1e7d300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c988f1b57284bb4589a7abc1e7d300b">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> &amp; <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; ElementType, throwOnFailure &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator </p>

</div>
</div>
<a id="ad7bbcb81fbcff1db2ab9365f22f25b52" name="ad7bbcb81fbcff1db2ab9365f22f25b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bbcb81fbcff1db2ab9365f22f25b52">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;class OtherElementType , bool otherThrowOnFailure, typename  = AllowConversion&lt;OtherElementType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a> &amp; <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; OtherElementType, otherThrowOnFailure &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converting move assignment operator. Only enabled if this is a HeapBlock&lt;Base*&gt; and the other object is a HeapBlock&lt;Derived*&gt;, where std::is_base_of_v&lt;Base, Derived&gt; == true. </p>

</div>
</div>
<a id="aef42df8e69f0805ccbb5d44f1df32a21" name="aef42df8e69f0805ccbb5d44f1df32a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef42df8e69f0805ccbb5d44f1df32a21">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const ElementType *&#160;</td>
          <td class="paramname"><em>otherPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares the pointer with another pointer. This can be handy for checking whether this is a null pointer. </p>

</div>
</div>
<a id="adba845b2dd3e84c2eeed3d61cad7241e" name="adba845b2dd3e84c2eeed3d61cad7241e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba845b2dd3e84c2eeed3d61cad7241e">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType &amp; <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to one of the data elements. Obviously there's no bounds-checking here, as this object is just a dumb pointer and has no idea of the size it currently has allocated. </p>

</div>
</div>
<a id="aef5d26dfb08dc6f0e63a5e2fb2545b3f" name="aef5d26dfb08dc6f0e63a5e2fb2545b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d26dfb08dc6f0e63a5e2fb2545b3f">&#9670;&#160;</a></span>realloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::realloc </td>
          <td>(</td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>sizeof&#160;(ElementType)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-allocates a specified amount of memory.</p>
<p>The semantics of this method are the same as malloc() and calloc(), but it uses <a class="el" href="classjuce_1_1_heap_block.html#aef5d26dfb08dc6f0e63a5e2fb2545b3f">realloc()</a> to keep as much of the existing data as possible. </p>

</div>
</div>
<a id="a4553291a09020d9b9f710d3db159a3d0" name="a4553291a09020d9b9f710d3db159a3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4553291a09020d9b9f710d3db159a3d0">&#9670;&#160;</a></span>swapWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType , bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;bool otherBlockThrows&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjuce_1_1_heap_block.html">juce::HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::swapWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>&lt; ElementType, otherBlockThrows &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps this object's data with the data of another <a class="el" href="classjuce_1_1_heap_block.html">HeapBlock</a>. The two objects simply exchange their data pointers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>modules/juce_core/memory/<a class="el" href="juce___heap_block_8h_source.html">juce_HeapBlock.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
